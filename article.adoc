= Going Reactive with WebFlux

== The Missing Metaphor

Reactive programming is an approach to writing software that embraces asynchronous IO. Asynchronous I/O is a small idea that portends big changes for software. The idea is simple: alleviate inefficient resource utilization by reclaiming resources that would otherwise be idle as they waited for I/O activity. Asynchronous IO inverts the normal design IO processing: the clients are notified of new data instead of asking for it; this frees the client to do other things while waiting for new notifications. There is always the risk that too many notifications will overwhelm a client. A client must be able to push back, rejecting work it can't handle. This is a fundamental aspect of flow control in distributed systems. In reactive programming, the ability of the client to signal how much work it can manage is called _backpressure_. Many projects - like Vert.x, Akka Streams, and RxJava - support reactive programming. The Spring team has a project called http://projectreactor.io[Reactor]. There's common ground across these different approaches extracted into a de-facto standard, http://www.reactive-streams.org[the Reactive Streams initiative]. The Reactive Streams initiative defines four types:

The `Publisher<T>` is a producer of values that may eventually arrive. A `Publisher<T>` produces values of type `T`.

.the Reactive Streams `Publisher<T>`.
====
[source,java,indent=0]
----
package org.reactivestreams;

public interface Publisher<T> {

    void subscribe(Subscriber<? super T> s);
}
----
====

The `Subscriber` subscribes to a `Publisher<T>`, receiving notifications on any new values of type `T`.

.the Reactive Streams `Subscriber<T>`.
====
[source,java,indent=0]
----
package org.reactivestreams;

public interface Subscriber<T> {

    public void onSubscribe(Subscription s);

    public void onNext(T t);

    public void onError(Throwable t);

    public void onComplete();
}
----
====

When a `Subscriber<T>` subscribes to a `Publisher<T>`, it results in a `Subscription<T>`.

.The Reactive Streams `Subscription<T>`.
====
[source,java,indent=0]
----
package org.reactivestreams;

public interface Subscription {

    public void request(long n);

    public void cancel();
}
----
====

A `Publisher<T>` that is also a `Subscriber<T>` is called a `Processor<T>`.

.The Reactive Streams `Processor<T>`.
====
[source,java,indent=0]
----
package org.reactivestreams;

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
----
====

The specification is not meant to be a prescription for the implementations,   instead defining types for interoperability. The Reactive Streams types eventually found their way into Java 9 as one to one semantically equivalent interfaces in the `java.util.concurrent.Flow` class.

##  Reactor
The Reactive Streams types are not enough; you'll need higher order implementations to support operators like filtering and transformation. Pivotal's Reactor project is a good choice here; it builds on top of the Reactive Streams specification. It provides two specializations of the `Publisher<T>`. The first, `Flux<T>`, is a Publisher that produces zero or more values. It's unbounded. The second, `Mono<T>`, is a `Publisher<T>` that produces zero or one value. They're both publishers and you can treat them that way, but they go much further than the  Reactive Streams specification. They both provide operators, ways to  process a stream of values. Reactor types compose nicely - the output of one thing can be the input to another.


## The Data Tier

## You've been Serv(-iced)!

## REST for Fun and Profit

## WebSockets


